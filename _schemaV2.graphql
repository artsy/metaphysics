directive @principalField on FIELD

type AccountRequest {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  notes: String
}

# One item in an aggregation
type AggregationCount {
  count: Int!
  name: String!
  value: String!
}

type Article implements Node {
  author: Author
  cached: Int
  channelID: String
  contributingAuthors: [Author]
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  publishedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  slug: String
  thumbnailImage: Image
  thumbnailTeaser: String
  thumbnailTitle: String
  tier: Int
  title: String
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
}

# A connection to a list of items.
type ArticleConnection {
  # A list of edges.
  edges: [ArticleEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArticleEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Article
}

enum ArticleSorts {
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
}

type Artist implements EntityWithFilterArtworksConnectionInterface & Node & Searchable {
  alternateNames: [String]
  articlesConnection(
    after: String
    before: String
    first: Int
    inEditorialFeed: Boolean
    last: Int
    limit: Int
    sort: ArticleSorts
  ): ArticleConnection
  artworksConnection(
    after: String
    before: String

    # List of artwork IDs to exclude from the response.
    exclude: [String]
    filter: [ArtistArtworksFilters]
    first: Int
    last: Int
    published: Boolean = true
    sort: ArtworkSorts
  ): ArtworkConnection
  auctionResultsConnection(
    after: String

    # Filter auction results by empty artwork created date values
    allowEmptyCreatedDates: Boolean = true
    before: String

    # Filter auction results by category (medium)
    categories: [String]

    # Filter auction results by earliest created at year
    earliestCreatedYear: Int
    first: Int
    last: Int

    # Filter auction results by latest created at year
    latestCreatedYear: Int

    # Filter auction results by organizations
    organizations: [String]

    # When true, will only return records for allowed artists.
    recordsTrusted: Boolean = false

    # Filter auction results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: AuctionResultSorts
  ): AuctionResultConnection

  # In applicable contexts, this is what the artist (as a suggestion) is based on.
  basedOn: Artist
  bio: String

  # The Artist biography article written by Artsy
  biography: Article
  biographyBlurb(
    format: Format

    # If true, will return featured bio over Artsy one.
    partnerBio: Boolean = false
  ): ArtistBlurb
  birthday: String
  blurb(format: Format): String
  cached: Int
  carousel: ArtistCarousel
  collections: [String]
  contemporary(
    excludeArtistsWithoutArtworks: Boolean = true

    # The number of Artists to return
    size: Int
  ): [Artist]
  counts: ArtistCounts
  currentEvent: CurrentEvent
  deathday: String
  disablePriceContext: Boolean
  displayLabel: String

  # Custom-sorted list of shows for an artist, in order of significance.
  exhibitionHighlights(
    # The number of Shows to return
    size: Int = 5
  ): [Show]

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A string showing the total number of works and those for sale
  formattedArtworksCount: String

  # A string of the form "Nationality, Birthday (or Birthday-Deathday)"
  formattedNationalityAndBirthday: String
  gender: String

  # A list of genes associated with an artist
  genes: [Gene]
  hasMetadata: Boolean
  highlights: ArtistHighlights
  hometown: String
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String
  initials(length: Int = 3): String
  insights: [ArtistInsight]

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isConsignable: Boolean

  # Only specific Artists should show a link to auction results.
  isDisplayAuctionLink: Boolean
  isFollowed: Boolean
  isPublic: Boolean
  isShareable: Boolean
  location: String
  meta: ArtistMeta
  name: String
  nationality: String
  partnerArtists(
    # The number of PartnerArtists to return
    size: Int
  ): [PartnerArtist]
  partnersConnection(
    after: String
    before: String
    first: Int
    last: Int
    partnerCategory: [String]
    representedBy: Boolean
  ): PartnerArtistConnection
  related: ArtistRelatedData
  sales(
    isAuction: Boolean
    live: Boolean

    # The number of Sales to return
    size: Int
    sort: SaleSorts
  ): [Sale]
  showsConnection(
    active: Boolean
    after: String
    atAFair: Boolean
    before: String
    first: Int
    isReference: Boolean
    last: Int

    # The number of PartnerShows to return
    size: Int
    soloShow: Boolean
    sort: ShowSorts
    status: String
    topTier: Boolean
    visibleToPublic: Boolean
  ): ShowConnection

  # A slug ID.
  slug: ID!

  # Use this attribute to sort by when sorting a collection of Artists
  sortableID: String
  statuses: ArtistStatuses
  targetSupply: ArtistTargetSupply
  years: String
}

type ArtistArtworkGrid implements ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

enum ArtistArtworksFilters {
  IS_FOR_SALE
  IS_NOT_FOR_SALE
}

type ArtistBlurb {
  credit: String

  # The partner id of the partner who submitted the featured bio.
  partnerID: String
  text: String
}

type ArtistCarousel {
  images: [Image]
}

# A connection to a list of items.
type ArtistConnection {
  # A list of edges.
  edges: [ArtistEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type ArtistCounts {
  articles: Int
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  auctionArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  ecommerceArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  follows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  forSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  hasMakeOfferArtworks: Boolean
  partnerShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  relatedArtists: Int
}

# An edge in a connection.
type ArtistEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artist
}

type ArtistGroup {
  # Artists sorted by last name
  items: [Artist]

  # Letter artists group belongs to
  letter: String
}

type ArtistHighlights {
  partnersConnection(
    after: String
    before: String
    displayOnPartnerProfile: Boolean
    first: Int
    last: Int
    partnerCategory: [String]
    representedBy: Boolean
  ): PartnerArtistConnection
}

type ArtistInsight {
  # List of entities relevant to the insight.
  entities: [String]

  # Label to use when displaying the insight.
  label: String

  # The type of insight.
  type: String
}

type ArtistMeta {
  description: String
  title: String
}

# A connection to a list of items.
type ArtistPartnerConnection {
  # A list of edges.
  edges: [ArtistPartnerEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArtistPartnerEdge {
  artist: Artist
  biography: String
  counts: PartnerArtistCounts

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isUseDefaultBiography: Boolean

  # The item at the end of the edge
  node: Artist
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

type ArtistRelatedData {
  artistsConnection(
    after: String
    before: String
    excludeArtistsWithoutArtworks: Boolean = true
    first: Int
    kind: RelatedArtistsKind
    last: Int
    minForsaleArtworks: Int
  ): ArtistConnection
  genes(after: String, before: String, first: Int, last: Int): GeneConnection

  # A list of the current user’s suggested artists, based on a single artist
  suggestedConnection(
    after: String
    before: String

    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # Exclude artists without any artworks
    excludeArtistsWithoutArtworks: Boolean

    # Exclude artists without for sale works
    excludeArtistsWithoutForsaleArtworks: Boolean

    # Exclude artists the user already follows
    excludeFollowedArtists: Boolean
    first: Int
    last: Int
  ): ArtistConnection
}

enum ArtistSorts {
  SORTABLE_ID_ASC
  SORTABLE_ID_DESC
  TRENDING_DESC
}

type ArtistStatuses {
  articles: Boolean
  artists: Boolean
  artworks: Boolean
  auctionLots: Boolean
  biography: Boolean
  contemporary: Boolean
  cv(
    # Suppress the cv tab when artist show count is less than this.
    minShowCount: Int = 15
  ): Boolean
  shows: Boolean
}

type ArtistTargetSupply {
  # True if an artist is in the microfunnel list.
  isInMicrofunnel: Boolean

  # True if artist is in target supply list.
  isTargetSupply: Boolean
  microfunnel: ArtistTargetSupplyMicrofunnel
}

type ArtistTargetSupplyMicrofunnel {
  # A list of recently sold artworks.
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Randomize the order of artworks for display purposes.
    randomize: Boolean
  ): ArtworkConnection
  metadata: TargetSupplyMicrofunnelMetadata
}

type Artwork implements Node & Searchable & Sellable {
  additionalInformation(format: Format): String
  articles(size: Int): [Article]
  artist(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): Artist
  artistNames: String
  artists(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): [Artist]

  # Represents the "**classification**" of an artwork, such as _limited edition_
  attributionClass: AttributionClass
  availability: String
  cached: Int

  # Can a user request a lot conditions report for this artwork?
  canRequestLotConditionsReport: Boolean

  # Represents the "**medium type**", such as _Painting_. (This field is also
  # commonly referred to as just "medium", but should not be confused with the
  # artwork attribute called `medium`.)
  category: String @deprecated(reason: "Prefer to use `mediumType`.")

  # Returns the display label and detail for artwork certificate of authenticity
  certificateOfAuthenticity: ArtworkInfoRow
  collectingInstitution: String
  conditionDescription: ArtworkInfoRow
  contactLabel: String

  # Pre-filled inquiry text
  contactMessage: String

  # Returns the associated Fair/Sale/Show
  context: ArtworkContext
  contextGrids: [ArtworkContextGrid]

  # The currency code used to pay for the artwork
  costCurrencyCode: String

  # The amount paid for the artwork, in cents
  costMinor: Int
  culturalMaker: String
  date: String

  # The depth as expressed by the original input metric
  depth: String
  description(format: Format): String
  dimensions: dimensions
  displayLabel: String
  displayPriceRange: Boolean
  editionNumber: String
  editionOf: String
  editionSet(id: String!): EditionSet
  editionSets(sort: EditionSetSorts): [EditionSet]
  editionSize: String

  # Returns an HTML string representing the embedded content (video)
  embed(autoplay: Boolean = false, height: Int = 450, width: Int = 853): String

  # Flags if artwork located in one of EU local shipping countries.
  euShippingOrigin: Boolean
  exhibitionHistory(format: Format): String
  fair: Fair

  # Formatted artwork metadata, including artist, title, date and partner; e.g., 'Andy Warhol, Truck, 1980, Westward Gallery'.
  formattedMetadata: String
  framed: ArtworkInfoRow

  # Returns true when artwork has a certificate of authenticity
  hasCertificateOfAuthenticity: Boolean

  # The height as expressed by the original input metric
  height: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  heightCm: Float

  # Returns the highlighted shows and articles
  highlights: [ArtworkHighlight]
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  imageRights: String
  images(size: Int): [Image]
  imageTitle: String
  imageUrl: String

  # Structured questions a collector can inquire on about this work
  inquiryQuestions: [InquiryQuestion]

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Private text field for partner use
  inventoryId: String

  # Whether a work can be purchased through e-commerce
  isAcquireable: Boolean

  # Is this artwork part of an auction that is currently running?
  isBiddable: Boolean

  # When in an auction, can the work be bought immediately
  isBuyNowable: Boolean
  isComparableWithAuctionResults: Boolean
  isDownloadable: Boolean
  isEdition: Boolean
  isEmbeddableVideo: Boolean
  isForSale: Boolean
  isHangable: Boolean

  # Is this artwork part of an auction?
  isInAuction: Boolean

  # Do we want to encourage inquiries on this work?
  isInquireable: Boolean

  # Is this artwork part of a current show
  isInShow: Boolean
  isNotForSale: String

  # Whether a user can make an offer on a work
  isOfferable: Boolean
  isOnHold: String
  isPriceHidden: Boolean
  isPriceRange: Boolean
  isSaved: Boolean
  isShareable: Boolean
  isSold: Boolean
  isUnique: Boolean
  layer(id: String): ArtworkLayer
  layers: [ArtworkLayer]
  listPrice: ListPrice
  literature(format: Format): String
  manufacturer(format: Format): String

  # Represents the **materials** used in this work, such as _oil and acrylic on
  # canvas_. (This should not be confused with the artwork attribute called
  # `category`, which is commonly referred to as "medium" or "medium type")
  medium: String

  # Represents the "**medium type**", such as _Painting_. (This field is also
  # commonly referred to as just "medium", but should not be confused with the
  # artwork attribute called `medium`.)
  mediumType: ArtworkMedium
  meta: ArtworkMeta

  # The unit of length of the artwork, expressed in `in` or `cm`
  metric: String
  myLotStanding(live: Boolean = null): [LotStanding!]

  # Is this work only available for shipping domestically?
  onlyShipsDomestically: Boolean
  partner(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): Partner
  pickupAvailable: Boolean
  price: String
  priceCurrency: String
  priceIncludesTax: Boolean
  priceIncludesTaxDisplay: String
  provenance(format: Format): String

  # Whether this artwork is published or not
  published: Boolean!
  publisher(format: Format): String

  # Price which an artwork was sold for. This generally only applies to artworks
  # in the target supply microfunnel and (currently) queries against hardcoded
  # spreadsheet data.
  realizedPrice: String
  realizedToEstimate: String
  related(size: Int): [Artwork]
  sale: Sale
  saleArtwork(saleID: String = null): SaleArtwork
  saleMessage: String
  series(format: Format): String

  # The country an artwork will be shipped from.
  shippingCountry: String

  # The string that describes domestic and international shipping.
  shippingInfo: String

  # Minimal location information describing from where artwork will be shipped.
  shippingOrigin: String

  # Is this work available for shipping only within the Contenental US?
  shipsToContinentalUSOnly: Boolean
    @deprecated(
      reason: "Prefer to use `onlyShipsDomestically`. [Will be removed in v2]"
    )
  show(active: Boolean, atAFair: Boolean, sort: ShowSorts): Show
  shows(active: Boolean, atAFair: Boolean, size: Int, sort: ShowSorts): [Show]
  signature(format: Format): String
  signatureInfo: ArtworkInfoRow

  # size bucket assigned to an artwork based on its dimensions
  sizeBucket: String

  # score assigned to an artwork based on its dimensions
  sizeScore: Float

  # A slug ID.
  slug: ID!
  title: String

  # Whether this artwork is unlisted or not
  unlisted: Boolean

  # If the category is video, then it returns the href for the (youtube/vimeo) video, otherwise returns the website from CMS
  website: String

  # The width as expressed by the original input metric
  width: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  widthCm: Float
}

enum ArtworkAggregation {
  ARTIST
  COLOR
  DIMENSION_RANGE
  FOLLOWED_ARTISTS
  GALLERY
  INSTITUTION
  MAJOR_PERIOD
  MEDIUM
  MERCHANDISABLE_ARTISTS
  PARTNER_CITY
  PERIOD
  PRICE_RANGE
  TOTAL
}

# A connection to a list of items.
type ArtworkConnection implements ArtworkConnectionInterface {
  # A list of edges.
  edges: [ArtworkEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

interface ArtworkConnectionInterface {
  edges: [ArtworkEdgeInterface]
  pageCursors: PageCursors!
  pageInfo: PageInfo!
}

union ArtworkContext = Fair | Sale | Show

# A specific grid.
interface ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# An edge in a connection.
type ArtworkEdge implements ArtworkEdgeInterface {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

interface ArtworkEdgeInterface {
  cursor: String
  node: Artwork
}

union ArtworkFilterFacet = Gene | Tag

union ArtworkHighlight = Article | Show

type ArtworkInfoRow {
  # Additional details about given attribute
  details: String

  # Label for information row
  label: String
}

# An inquiry on an Artwork
type ArtworkInquiry {
  artwork: Artwork!

  # A globally unique ID.
  id: ID!
  impulseConversationID: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type ArtworkInquiryConnection {
  # A list of edges.
  edges: [ArtworkInquiryEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ArtworkInquiryEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ArtworkInquiry
}

type ArtworkLayer {
  # A connection of artworks from a Layer.
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  description: String
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String
  type: String
}

# Collection of fields that describe medium type, such as _Painting_. (This field
# is also commonly referred to as just "medium", but should not be confused with
# the artwork attribute called `medium`.)
type ArtworkMedium {
  # Long descriptive phrase
  longDescription: String

  # Shortest form of medium type display
  name: String
}

type ArtworkMeta {
  description(limit: Int = 155): String
  image: String
  share: String
  title: String
}

type ArtworkMutationDeleteSuccess {
  success: Boolean
}

type ArtworkMutationFailure {
  mutationError: GravityMutationError
}

union ArtworkMutationType =
    ArtworkMutationDeleteSuccess
  | ArtworkMutationFailure

union ArtworkOrEditionSetType = Artwork | EditionSet

# The results for one of the requested aggregations
type ArtworksAggregationResults {
  counts: [AggregationCount]
  slice: ArtworkAggregation
}

enum ArtworkSizes {
  LARGE
  MEDIUM
  SMALL
}

enum ArtworkSorts {
  AVAILABILITY_ASC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
  ICONICITY_DESC
  MERCHANDISABILITY_DESC
  PARTNER_UPDATED_AT_DESC
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
  TITLE_ASC
  TITLE_DESC
}

type ArtworkVersion implements Node {
  # The names for the artists related to this Artwork Version
  artistNames: String

  # The artists related to this Artwork Version
  artists: [Artist]

  # The Image id
  defaultImageID: String

  # A globally unique ID.
  id: ID!

  # The image representing the Artwork Version
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Artwork title
  title: String
}

# Fields of an attachment (currently from Radiation)
type Attachment {
  # Content type of file.
  contentType: String!

  # URL of attachment.
  downloadURL: String!

  # File name.
  fileName: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# Collection of fields that describe attribution class
type AttributionClass {
  # A globally unique ID.
  id: ID!
  info: String @deprecated(reason: "Prefer `shortDescription`")

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Long description (can include multiple sentences) for attribution class
  longDescription: String

  # Shortest form of attribution class display
  name: String

  # Short descriptive phrase for attribution class without punctuation
  shortDescription: String
}

type AuctionArtworkGrid implements ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# In centimeters.
type AuctionLotDimensions {
  depth: Float
  height: Float
  width: Float
}

type AuctionLotEstimate {
  display: String
  high: Float
  low: Float
}

type AuctionLotImages {
  larger: Image
  thumbnail: Image
}

type AuctionResult implements Node {
  artistID: String!
  boughtIn: Boolean
  categoryText: String
  currency: String
  date(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  dateText: String
  description: String
  dimensions: AuctionLotDimensions
  dimensionText: String
  estimate: AuctionLotEstimate
  externalURL: String

  # A globally unique ID.
  id: ID!
  images: AuctionLotImages

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  location: String
  mediumText: String
  organization: String
  priceRealized: AuctionResultPriceRealized
  saleDate(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  saleDateText: String
  saleTitle: String
  title: String
}

# A connection to a list of items.
type AuctionResultConnection {
  createdYearRange: YearRange

  # A list of edges.
  edges: [AuctionResultEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type AuctionResultEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: AuctionResult
}

type AuctionResultPriceRealized {
  cents: Float
  centsUSD: Float
  display(
    # Passes in to numeral, such as `'0.00'`
    format: String = ""
  ): String
}

enum AuctionResultSorts {
  DATE_DESC
  ESTIMATE_AND_DATE_DESC
  PRICE_AND_DATE_DESC
}

type Author {
  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String
  profileHandle: String
}

type Bidder implements Node {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  pin: String
  qualifiedForBidding: Boolean
  sale: Sale
  user: User
}

type BidderPosition {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  highestBid: HighestBid

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActive: Boolean
  isRetracted: Boolean
  isWinning: Boolean
  isWithBidMax: Boolean
  maxBid: BidderPositionMaxBid
  processedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  saleArtwork: SaleArtwork
  suggestedNextBid: BidderPositionSuggestedNextBid
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
}

input BidderPositionInput {
  artworkID: String!
  clientMutationId: String
  maxBidAmountCents: Float!
  saleID: String!
}

type BidderPositionMaxBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type BidderPositionPayload {
  clientMutationId: String
  result: BidderPositionResult
}

type BidderPositionResult {
  messageDescriptionMD: String
  messageHeader: String
  position: BidderPosition
  status: String!
}

type BidderPositionSuggestedNextBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type BidIncrement {
  amount: Int
  from: Int
  to: Int
}

type BidIncrementsFormatted {
  cents: Float
  display: String
}

type BuyersPremium {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  percent: Float
}

type CalculatedCost {
  bidAmount: Money
  buyersPremium: Money
  subtotal: Money
}

type City {
  coordinates: LatLng
  fairsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: FairSorts
    status: EventStatus
  ): FairConnection
  name: String
  showsConnection(
    after: String
    before: String

    # Only used when status is CLOSING_SOON or UPCOMING. Number of days used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int

    # Whether to include local discovery stubs
    includeStubShows: Boolean
    last: Int

    # Filter shows by partner type
    partnerType: PartnerShowPartnerType
    sort: ShowSorts

    # Filter shows by chronological event status
    status: EventStatus
  ): ShowConnection
  slug: String
  sponsoredContent: CitySponsoredContent
}

type CitySponsoredContent {
  artGuideUrl: String
  featuredShows: [Show]
  introText: String
  showsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: ShowSorts
    status: EventStatus
  ): ShowConnection
}

enum CollectionSorts {
  POSITION_ASC
  POSITION_DESC
}

type CollectorProfileType {
  collectorLevel: Int
  confirmedBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  email: String

  # A globally unique ID.
  id: ID!
  intents: [String]

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  loyaltyApplicantAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  name: String
  professionalBuyerAppliedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  professionalBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  selfReportedPurchases: String
}

type ConvectionService {
  geminiTemplateKey: String!
}

# A conversation.
type Conversation implements Node {
  # Only the artworks discussed in the conversation.
  artworks: [Artwork]
  buyerOutcome: String
  buyerOutcomeAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # The participant who initiated the conversation
  from: ConversationInitiator!
  fromLastViewedMessageID: String

  # A globally unique ID.
  id: ID!
  initialMessage: String!
    @deprecated(
      reason: "This field is no longer required. Prefer the first message from the MessageConnection."
    )

  # Gravity inquiry id.
  inquiryID: String

  # An optional type-specific ID.
  internalID: ID

  # True if user/conversation initiator is a recipient.
  isLastMessageToUser: Boolean

  # The artworks and/or partner shows discussed in the conversation.
  items: [ConversationItem]

  # This is a snippet of text from the last message.
  lastMessage: String
  lastMessageAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Delivery id if the user is a recipient of the last message, null otherwise.
  lastMessageDeliveryID: String

  # Impulse id of the last message.
  lastMessageID: String
    @deprecated(
      reason: "Prefer querying `messagesConnection(last:1) { edges { node { internalID } } }`"
    )

  # A connection for all messages in a single conversation
  messages(
    after: String
    before: String
    first: Int
    last: Int
    sort: sort
  ): MessageConnection @deprecated(reason: "Prefer messagesConnection")

  # A connection for all messages in a single conversation
  messagesConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: sort
  ): MessageConnection

  # The participant(s) responding to the conversation
  to: ConversationResponder!

  # True if there is an unread message by the user.
  unread: Boolean
}

# A connection to a list of items.
type ConversationConnection {
  # A list of edges.
  edges: [ConversationEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalUnreadCount: Int
}

# An edge in a connection.
type ConversationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Conversation
}

# The participant who started the conversation, currently always a User
type ConversationInitiator {
  email: String!

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # The type of participant, e.g. Partner or User
  type: String!
}

type ConversationItem {
  item: ConversationItemType
  permalink: String
  title: String
}

union ConversationItemType = Artwork | Show

# The participant responding to the conversation, currently always a Partner
type ConversationResponder {
  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # An array of Impulse IDs that correspond to all email addresses that messages should be sent to
  replyToImpulseIDs: [String]!

  # The type of participant, e.g. Partner or User
  type: String!
}

type CreateAccountRequestMutationFailure {
  mutationError: GravityMutationError
}

input CreateAccountRequestMutationInput {
  # Type of account request.
  action: String
  clientMutationId: String

  # Email to associate with message.
  email: String

  # Name to associate with message.
  name: String

  # Message to be sent.
  notes: String!

  # Used when logged in.
  userID: String
}

type CreateAccountRequestMutationPayload {
  accountRequestOrError: CreateAccountRequestMutationType
  clientMutationId: String
}

type CreateAccountRequestMutationSuccess {
  accountRequest: AccountRequest
}

union CreateAccountRequestMutationType =
    CreateAccountRequestMutationFailure
  | CreateAccountRequestMutationSuccess

input CreateBidderInput {
  clientMutationId: String
  saleID: String!
}

type CreateBidderPayload {
  bidder: Bidder
  clientMutationId: String
}

input CreateGeminiEntryForAssetInput {
  clientMutationId: String

  # Additional JSON data to pass through gemini, should definitely contain an `id` and a `_type`
  metadata: JSON!

  # The S3 bucket where the file was uploaded
  sourceBucket: String!

  # The path to the file
  sourceKey: String!

  # The template key, this is `name` in the asset request
  templateKey: String!
}

type CreateGeminiEntryForAssetPayload {
  asset: GeminiEntry
  clientMutationId: String
}

# An asset which is assigned to a consignment submission
type Credentials {
  # The key to use with S3.
  credentials: String!

  # The s3 policy document for your request
  policyDocument: S3PolicyDocumentType!

  # A base64 encoded version of the S3 policy
  policyEncoded: String!

  # The signature for your asset.
  signature: String!
}

type CreditCard {
  # Brand of credit card
  brand: String!

  # Billing address city
  city: String

  # Billing address country code
  country: String

  # Credit card's expiration month
  expirationMonth: Int!

  # Credit card's expiration year
  expirationYear: Int!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Last four digits on the credit card
  lastDigits: String!

  # Name on the credit card
  name: String

  # Billing address postal code
  postalCode: String

  # Billing address state
  state: String

  # Billing address street1
  street1: String

  # Billing address street2
  street2: String
}

# A connection to a list of items.
type CreditCardConnection {
  # A list of edges.
  edges: [CreditCardEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CreditCardEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: CreditCard
}

input CreditCardInput {
  clientMutationId: String
  oneTimeUse: Boolean = false
  token: String!
}

type CreditCardMutationFailure {
  mutationError: GravityMutationError
}

type CreditCardMutationSuccess {
  creditCard: CreditCard
  creditCardEdge: CreditCardEdge
}

union CreditCardMutationType =
    CreditCardMutationFailure
  | CreditCardMutationSuccess

type CreditCardPayload {
  clientMutationId: String
  creditCardOrError: CreditCardMutationType
}

type CroppedImageUrl {
  height: Int!
  src: String!
  srcSet: String!
  url: String!
  width: Int!
}

type CurrentEvent {
  # Location and date of the event if available
  details: String
  event: UnderlyingCurrentEvent!

  # Link to the event
  href: String
  image: Image

  # Name of the event
  name: String

  # Name of the partner associated to the event
  partner: String

  # The state of the event
  status: String
}

type DaySchedule {
  dayOfWeek: String
  endTime: Int
  startTime: Int
}

type DeepZoom {
  Image: DeepZoomImage
}

type DeepZoomImage {
  Format: String
  Overlap: Int
  Size: DeepZoomImageSize
  TileSize: Int
  Url: String
  xmlns: String
}

type DeepZoomImageSize {
  Height: Int
  Width: Int
}

input DeleteArtworkImageInput {
  artworkID: String!
  clientMutationId: String
  imageID: String!
}

type DeleteArtworkImagePayload {
  artworkOrError: ArtworkMutationType
  clientMutationId: String
}

input DeleteCreditCardInput {
  clientMutationId: String
  id: String!
}

type DeleteCreditCardPayload {
  clientMutationId: String
  creditCardOrError: CreditCardMutationType
}

# Fields of a delivery (currently from Radiation)
type Delivery {
  bouncedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  clickedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  deliveredAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Masked email w/ display name.
  fullTransformedEmail: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  openedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
}

type dimensions {
  cm: String
  in: String
}

input EditableLocation {
  # First line of an address
  address: String

  # Second line of an address
  address2: String

  # The city the location is based in
  city: String

  # The county the location is based in
  country: String

  # Postal code for a string
  postalCode: String

  # The (optional) name of the state for location
  state: String

  # The (optional) state code of the state for location
  stateCode: String

  # An optional display string for the location
  summary: String
}

type EditionSet implements Sellable {
  dimensions: dimensions
  displayPriceRange: Boolean
  editionOf: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  heightCm: Float

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isAcquireable: Boolean
  isForSale: Boolean
  isOfferable: Boolean
  isSold: Boolean
  listPrice: ListPrice
  price: String
  saleMessage: String

  # size bucket assigned to an artwork based on its dimensions
  sizeBucket: String

  # score assigned to an artwork based on its dimensions
  sizeScore: Float

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  widthCm: Float
}

enum EditionSetSorts {
  PRICE_ASC
}

input EndSaleInput {
  clientMutationId: String
  saleID: String
}

type EndSalePayload {
  clientMutationId: String
  sale: Sale
}

interface EntityWithFilterArtworksConnectionInterface {
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A globally unique ID.
  id: ID!
}

enum EventStatus {
  # End date is in the past
  CLOSED

  # End date is in near future
  CLOSING_SOON

  # Start date or end date is in the future
  CURRENT

  # Start date is in the past and end date is in the future
  RUNNING

  # Special filtering option which is used to show running and upcoming shows
  RUNNING_AND_UPCOMING

  # Start date is in the future
  UPCOMING
}

type ExternalPartner {
  city: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String
}

type Fair implements EntityWithFilterArtworksConnectionInterface & Node {
  about(format: Format): String
  activeStartAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  articlesConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: ArticleSorts
  ): ArticleConnection
  artistsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Sorts for artists in a fair
    sort: FairArtistSorts
  ): ArtistConnection
  bannerSize: String
  cached: Int
  contact(format: Format): String
  counts: FairCounts
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A formatted description of the start to end dates
  exhibitionPeriod: String

  # The exhibitors with booths in this fair with letter.
  exhibitorsGroupedByName: [FairExhibitorsGroup]

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  followedContent: FollowedContent

  # A formatted description of when the fair starts or closes or if it is closed
  formattedOpeningHours: String
  hasFullFeature: Boolean
  hasHomepageSection: Boolean
  hasLargeBanner: Boolean
  hasListing: Boolean
  hours(format: Format): String
  href: String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Are we currently in the fair's active period?
  isActive: Boolean
  isPublished: Boolean
  kawsCollectionSlugs: [String]!
  links(format: Format): String
  location: Location
  mobileImage: Image
  name: String
  organizer: organizer
  profile: Profile

  # This connection only supports forward pagination. We're replacing Relay's default cursor with one from Gravity.
  showsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Number of artworks to return
    section: String

    # Sorts for shows in a fair
    sort: ShowSorts
    totalCount: Boolean = false
  ): ShowConnection

  # A slug ID.
  slug: ID!
  sponsoredContent: FairSponsoredContent
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  summary(format: Format): String
  tagline: String
  tickets(format: Format): String
  ticketsLink: String
}

enum FairArtistSorts {
  NAME_ASC
  NAME_DESC
}

# A connection to a list of items.
type FairConnection {
  # A list of edges.
  edges: [FairEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type FairCounts {
  artists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partners(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type FairEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Fair
}

type FairExhibitor {
  # Exhibitor name
  name: String

  # Exhibitors _id
  partnerID: String

  # Partner default profile id
  profileID: String

  # A slug ID.
  slug: ID!
}

type FairExhibitorsGroup {
  # The exhibitor data.
  exhibitors: [FairExhibitor]

  # Letter exhibitors group belongs to
  letter: String
}

enum FairSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  START_AT_ASC
  START_AT_DESC
}

type FairSponsoredContent {
  activationText: String
  pressReleaseUrl: String
}

# A Feature
type Feature {
  callout(format: Format): String
  description(format: Format): String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActive: Boolean!
  layout: FeatureLayouts!
  meta: FeatureMeta!
  name: String!

  # Features are composed of sets, which are themselves composed of items of various types
  setsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: OrderedSetSorts = KEY_ASC
  ): OrderedSetConnection

  # A slug ID.
  slug: ID!
  subheadline(format: Format): String
}

# An illustrated link chosen to highlight a Gene from a given GeneFamily
type FeaturedGeneLink {
  href: String!
  image: Image
  internalID: String!
  title: String!
}

type FeaturedLink {
  description(format: Format): String
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: String
  subtitle(format: Format): String
  title: String
}

enum FeatureLayouts {
  DEFAULT
  FULL
}

# Meta-tag related fields for Features
type FeatureMeta {
  description: String!
  image: String
  name: String!
}

type Feedback {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Feedback message
  message: String!
}

type FieldErrorResults {
  message: String!
  name: String!
}

# A connection to a list of items.
type FilterArtworksConnection implements ArtworkConnectionInterface & Node {
  # Returns aggregation counts for the given filter query.
  aggregations: [ArtworksAggregationResults]
  counts: FilterArtworksCounts

  # A list of edges.
  edges: [FilterArtworksEdge]
  facet: ArtworkFilterFacet

  # Artwork results.
  hits: [Artwork]
    @deprecated(reason: "Prefer to use `edges`. [Will be removed in v2]")

  # The ID of the object.
  id: ID!

  # Returns a list of merchandisable artists sorted by merch score.
  merchandisableArtists(
    # The number of artists to return
    size: Int = 12
  ): [Artist]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type FilterArtworksCounts {
  followedArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  total(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type FilterArtworksEdge implements ArtworkEdgeInterface {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

type FilterSaleArtworksCounts {
  followedArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  total(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type FollowArtist {
  artist: Artist
  auto: Boolean

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type FollowArtistConnection {
  # A list of edges.
  edges: [FollowArtistEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type FollowArtistCounts {
  artists: Int
}

# An edge in a connection.
type FollowArtistEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowArtist
}

input FollowArtistInput {
  artistID: String!
  clientMutationId: String
  unfollow: Boolean = false
}

type FollowArtistPayload {
  artist: Artist
  clientMutationId: String

  # Popular artists
  popularArtists(
    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # If true, will exclude followed artists for the user
    excludeFollowedArtists: Boolean

    # Number of results to return
    size: Int
  ): [Artist]
}

type FollowArtists {
  artists: [Artist]
  counts: FollowArtistCounts
}

type FollowedArtistsArtworksGroup implements Node {
  artists: String
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  publishedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  summary: String
}

# A connection to a list of items.
type FollowedArtistsArtworksGroupConnection {
  # A list of edges.
  edges: [FollowedArtistsArtworksGroupEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedArtistsArtworksGroupEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowedArtistsArtworksGroup
}

type FollowedContent {
  artists: [Artist]
  galleries: [Partner]
}

# A connection to a list of items.
type FollowedFairConnection {
  # A list of edges.
  edges: [FollowedFairEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedFairEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Fair
}

# A connection to a list of items.
type FollowedGalleryConnection {
  # A list of edges.
  edges: [FollowedGalleryEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedGalleryEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Partner
}

# A connection to a list of items.
type FollowedShowConnection {
  # A list of edges.
  edges: [FollowedShowEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedShowEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Show
}

type FollowGene {
  gene: Gene

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type FollowGeneConnection {
  # A list of edges.
  edges: [FollowGeneEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowGeneEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowGene
}

input FollowGeneInput {
  clientMutationId: String
  geneID: String
}

type FollowGenePayload {
  clientMutationId: String
  gene: Gene
}

input FollowProfileInput {
  clientMutationId: String
  profileID: String
  unfollow: Boolean = false
}

type FollowProfilePayload {
  clientMutationId: String
  profile: Profile
}

type FollowsAndSaves {
  # A Connection of followed artists by current user
  artistsConnection(
    after: String
    before: String
    fairID: String
    first: Int
    last: Int
  ): FollowArtistConnection
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
    private: Boolean = false
    sort: CollectionSorts
  ): SavedArtworksConnection

  # A list of published artworks by followed artists (grouped by date and artists).
  bundledArtworksByArtistConnection(
    after: String
    before: String
    first: Int
    forSale: Boolean
    last: Int
    sort: ArtworkSorts
  ): FollowedArtistsArtworksGroupConnection

  # A list of the current user’s currently followed fair profiles
  fairsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowedFairConnection

  # A list of the current user’s currently followed gallery profiles
  galleriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowedGalleryConnection

  # A list of the current user’s inquiry requests
  genesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowGeneConnection

  # A list of the current user’s currently followed shows
  showsConnection(
    after: String
    before: String

    # A string representing one of the supported cities in the City Guide, which
    # are: new-york-ny-usa, los-angeles-ca-usa, london-united-kingdom,
    # berlin-germany, paris-france, hong-kong-hong-kong
    city: String

    # Number of days which will be used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int
    last: Int
    status: EventStatus
  ): FollowedShowConnection
}

input FollowShowInput {
  clientMutationId: String
  partnerShowID: String
  unfollow: Boolean = false
}

type FollowShowPayload {
  clientMutationId: String
  show: Show
}

enum Format {
  HTML
  MARKDOWN
  PLAIN
}

type FormattedDaySchedules {
  days: String
  hours: String
}

# The `FormattedNumber` type represents a number that can optionally be returnedas
# a formatted String. It does not try to coerce the type.
scalar FormattedNumber

# An entry from gemini
type GeminiEntry {
  # The token that represents the gemini entry.
  token: String!
}

type Gene implements Node & Searchable {
  artistsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtistConnection
  cached: Int
  description: String
  displayLabel: String
  displayName: String

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isFollowed: Boolean
  isPublished: Boolean
  mode: String
  name: String

  # A list of genes similar to the specified gene
  similar(
    after: String
    before: String

    # Array of gene ids (not slugs) to exclude, may result in all genes being excluded.
    excludeGeneIDs: [String]
    first: Int
    last: Int
  ): GeneConnection

  # A slug ID.
  slug: ID!
  trendingArtists(sample: Int): [Artist]
}

# A connection to a list of items.
type GeneConnection {
  # A list of edges.
  edges: [GeneEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type GeneEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Gene
}

# A user-facing thematic grouping of Genes
type GeneFamily {
  featuredGeneLinks: [FeaturedGeneLink]
  genes: [Gene]

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # A slug ID.
  slug: ID!
}

# A connection to a list of items.
type GeneFamilyConnection {
  # A list of edges.
  edges: [GeneFamilyEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type GeneFamilyEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: GeneFamily
}

type GravityMutationError {
  detail: String
  error: String
  fieldErrors: [FieldErrorResults]
  message: String
  type: String
}

type HighestBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  display: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isCancelled: Boolean
  number: Int
}

type Highlights {
  # List of curated genes that are broad collecting. (Meant for e.g. suggestions in on-boarding.)
  broadCollectingGenes: [Gene]

  # Popular artists
  popularArtists(
    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # If true, will exclude followed artists for the user
    excludeFollowedArtists: Boolean

    # Number of results to return
    size: Int
  ): [Artist]
}

type HomePage {
  # Single artist module to show on the home screen.
  artistModule(
    # Module identifier.
    key: HomePageArtistModuleTypes
  ): HomePageArtistModule

  # Artist modules to show on the home screen
  artistModules: [HomePageArtistModule]

  # Single artwork module to show on the home screen
  artworkModule(
    # ID of followed artist to target for related artist rails
    followedArtistID: String

    # ID of generic gene rail to target
    id: String

    # Module key
    key: String

    # ID of related artist to target for related artist rails
    relatedArtistID: String
  ): HomePageArtworkModule

  # Artwork modules to show on the home screen
  artworkModules(
    # Exclude certain modules
    exclude: [HomePageArtworkModuleTypes] = []

    # Maximum number of followed genes to return, disable with a negative number
    maxFollowedGeneRails: Int = 1

    # Maximum number of modules to return, disable limit with a negative number
    maxRails: Int = 8

    # The preferred order of modules, defaults to order returned by Gravity
    order: [HomePageArtworkModuleTypes]
  ): [HomePageArtworkModule]
  fairsModule: HomePageFairsModule

  # A list of enabled hero units to show on the requested platform
  heroUnits(platform: HomePageHeroUnitPlatform!): [HomePageHeroUnit]
  salesModule: HomePageSalesModule
}

type HomePageArtistModule implements Node {
  # A globally unique ID.
  id: ID!

  # Module identifier.
  key: String
  results: [Artist]
}

enum HomePageArtistModuleTypes {
  # The most searched for artists.
  POPULAR

  # Artists recommended for the specific user.
  SUGGESTED

  # The trending artists.
  TRENDING
}

type HomePageArtworkModule implements Node {
  context: HomePageArtworkModuleContext

  # A globally unique ID.
  id: ID!
  isDisplayable: Boolean
  key: String
  params: HomePageModulesParams
  results: [Artwork]
  title: String
}

union HomePageArtworkModuleContext =
    Fair
  | FollowArtists
  | Gene
  | HomePageFollowedArtistArtworkModule
  | HomePageRelatedArtistArtworkModule
  | Sale
  | TrendingArtists

enum HomePageArtworkModuleTypes {
  ACTIVE_BIDS
  CURRENT_FAIRS
  FOLLOWED_ARTIST
  FOLLOWED_ARTISTS
  FOLLOWED_GALLERIES
  FOLLOWED_GENES
  GENERIC_GENES
  LIVE_AUCTIONS
  POPULAR_ARTISTS
  RECENTLY_VIEWED_WORKS
  RECOMMENDED_WORKS
  RELATED_ARTISTS
  SAVED_WORKS
  SIMILAR_TO_RECENTLY_VIEWED
  SIMILAR_TO_SAVED_WORKS
}

type HomePageFairsModule {
  results: [Fair]!
}

type HomePageFollowedArtistArtworkModule {
  artist: Artist
}

type HomePageHeroUnit {
  # The image to show, on desktop this defaults to the wide version.
  backgroundImageURL(version: HomePageHeroUnitImageVersion): String
  cached: Int
  creditLine: String
  heading: String
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  linkText: String
  mode: HomePageHeroUnitMode

  # A slug ID.
  slug: ID!
  subtitle: String
  title: String
  titleImageURL(retina: Boolean): String
}

enum HomePageHeroUnitImageVersion {
  NARROW
  WIDE
}

enum HomePageHeroUnitMode {
  CENTERED_DARK
  CENTERED_LIGHT
  LEFT_DARK
  LEFT_LIGHT
  RIGHT_DARK
  RIGHT_LIGHT
}

enum HomePageHeroUnitPlatform {
  DESKTOP
  MARTSY
  MOBILE
}

type HomePageModulesParams {
  followedArtistID: ID
  geneID: String

  # An optional type-specific ID.
  internalID: ID
  medium: String
  priceRange: String
  relatedArtistID: ID
}

type HomePageRelatedArtistArtworkModule {
  artist: Artist
  basedOn: Artist
}

type HomePageSalesModule {
  results: [Sale]!
}

type IdentityVerification {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  invitationExpiresAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Where the identity verification is in its lifecycle
  state: String!

  # User ID of the identity verification's owner
  userID: String!
}

type Image {
  aspectRatio: Float!
  caption: String
  cropped(height: Int!, version: [String], width: Int!): CroppedImageUrl
  deepZoom: DeepZoom
  height: Int
  href: String
  imageURL: String
  imageVersions: [String]

  # An optional type-specific ID.
  internalID: ID
  isDefault: Boolean
  isZoomable: Boolean
  maxTiledHeight: Int
  maxTiledWidth: Int
  orientation: String
  originalHeight: Int
  originalWidth: Int

  # Value to use when `padding-bottom` for fluid image placeholders
  placeholder: String
  position: Int
  resized(height: Int, version: [String], width: Int): ResizedImageUrl
  tileBaseURL: String
  tileFormat: String
  tileSize: Int
  title: String
  url(version: [String]): String
  versions: [String]
  width: Int
}

union InquiryItemType = Artwork | Show

type InquiryQuestion {
  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  question: String!
}

input InquiryQuestionInput {
  details: String
  questionID: String!
}

# A request to inquire on an artwork
type InquiryRequest {
  # A globally unique ID.
  id: ID!
  inquireable: InquiryItemType
  inquirer: User

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  questions: [String]
  shippingLocation: Location
}

enum Intents {
  BUY_ART_AND_DESIGN
  FIND_ART_EXHIBITS
  LEARN_ABOUT_ART
  READ_ART_MARKET_NEWS
  RESEARCH_ART_PRICES
  SELL_ART_AND_DESIGN
}

# Fields of an invoice (currently from Lewitt)
type Invoice implements Node {
  # A globally unique ID.
  id: ID!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # A type-specific ID likely used as a database ID.
  internalID: ID!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Lewitt's invoice id.
  lewittInvoiceID: String!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Link to public checkout page.
  paymentURL: String
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Current state of invoice.
  state: InvoiceState
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # A formatted price with various currency formatting options.
  total(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )
}

enum InvoiceState {
  PAID
  REFUNDED
  UNPAID
  VOID
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type LatLng {
  lat: Float
  lng: Float
}

union ListPrice = Money | PriceRange

type Location {
  address: String
  address2: String
  cached: Int
  city: String
  coordinates: LatLng
  country: String
  daySchedules: [DaySchedule]

  # Alternate Markdown-supporting free text representation of a location's opening hours
  dayScheduleText: String
  display: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!

  # Union returning opening hours in formatted structure or a string
  openingHours: OpeningHoursUnion
  phone: String
  postalCode: String
  state: String
  summary: String
}

# A connection to a list of items.
type LocationConnection {
  # A list of edges.
  edges: [LocationEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type LocationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Location
}

type LotStanding {
  # Your bid if it is currently winning
  activeBid: BidderPosition
  bidder: Bidder

  # You are winning and reserve is met
  isHighestBidder: Boolean

  # You are the leading bidder without regard to reserve
  isLeadingBidder: Boolean

  # Your most recent bid—which is not necessarily winning (may be higher or lower)
  mostRecentBid: BidderPosition
  sale: Sale
  saleArtwork: SaleArtwork
}

type Me implements Node {
  # A list of the current user’s inquiry requests
  artworkInquiriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkInquiryConnection

  # Returns a single bidder position
  bidderPosition(id: String!): BidderPositionResult

  # A list of the current user's bidder positions
  bidderPositions(
    # Only the bidder positions on a specific artwork
    artworkID: String

    # Only the most recent bidder positions per artwork.
    current: Boolean

    # Only the bidder positions for a specific auction
    saleID: String
  ): [BidderPosition]

  # A list of the current user’s bidder registrations
  bidders(
    # Limit results to bidders in active auctions
    active: Boolean

    # The slug or ID of a Sale
    saleID: String
  ): [Bidder]

  # The current user's status relating to bids on artworks
  bidderStatus(artworkID: String!, saleID: String!): LotStanding

  # Whether user is allowed to request email confirmation
  canRequestEmailConfirmation: Boolean!

  # A collector profile.
  collectorProfile: CollectorProfileType

  # A conversation, usually between a user and a partner
  conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Conversations, usually between a user and partner.
  conversationsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ConversationConnection
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A list of the current user’s credit cards
  creditCards(
    after: String
    before: String
    first: Int
    last: Int
  ): CreditCardConnection
  email: String

  # Frequency of marketing emails.
  emailFrequency: String
  followsAndSaves: FollowsAndSaves
  hasCreditCards: Boolean
  hasPassword: Boolean!
  hasQualifiedCreditCards: Boolean
  hasSecondFactorEnabled: Boolean!

  # A globally unique ID.
  id: ID!

  # An identity verification that the user has access to
  identityVerification(
    # ID of the IdentityVerification
    id: String!
  ): IdentityVerification
  identityVerified: Boolean
  initials(length: Int = 3): String

  # A type-specific ID.
  internalID: ID!

  # An invoice
  invoice(
    # The ID of the Conversation
    conversationId: String!

    # The ID of the invoice
    invoiceId: String!
  ): Invoice
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )

  # List of lab features for this user
  labFeatures: [String!]!

  # Sale Artworks search results
  lotsByFollowedArtistsConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    estimateRange: String
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    page: Int
    saleID: ID
    size: Int
    sort: String
  ): SaleArtworksConnection

  # The current user's status relating to bids on artworks
  lotStanding(
    artworkID: String
    saleArtworkID: String
    saleID: String
  ): LotStanding

  # A list of the current user's auction standings for given lots
  lotStandings(
    # Only includes lots on which you have a leading bidder position.
    activePositions: Boolean

    # Only the lot standings on a specific artwork
    artworkID: String

    # Only the lot standings for currently open or closed auctions.
    live: Boolean
    saleArtworkID: String

    # Only the lot standings for a specific auction
    saleID: String
  ): [LotStanding]
  myCollectionConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: MyCollectionArtworkSorts
  ): MyCollectionConnection
  name: String
  paddleNumber: String

  # The user's most current pending identity verification, if it exists
  pendingIdentityVerification: IdentityVerification
  phone: String

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean
  recentlyViewedArtworkIds: [String]!

  # A list of the current user’s recently viewed artworks.
  recentlyViewedArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  saleRegistrationsConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts
  ): SaleRegistrationConnection
  type: String

  # The count of conversations with unread messages.
  unreadConversationCount: Int!

  # A count of unread notifications.
  unreadNotificationsCount: Int!
}

# A message in a conversation.
type Message implements Node {
  attachments: [Attachment]

  # Unaltered text if possible, otherwise `body`: a parsed/sanitized version from Sendgrid.
  body: String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  deliveries: [Delivery]
  from: MessageInitiator

  # A globally unique ID.
  id: ID!

  # Impulse message id.
  impulseID: String! @deprecated(reason: "Prefer internalID")

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  invoice: Invoice
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )

  # True if message is the first in the conversation.
  isFirstMessage: Boolean

  # True if message is from the user to the partner.
  isFromUser: Boolean

  # True if message is an invoice message
  isInvoice: Boolean
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )
}

# A connection to a list of items.
type MessageConnection {
  # A list of edges.
  edges: [MessageEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type MessageEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Message
}

# The participant who sent the message.
type MessageInitiator {
  email: String
  name: String
}

type MetaphysicsService {
  environment: String!
  heapDumps: Boolean!
  queryTracing: Boolean!
  stitching: Boolean!
  stitchingConvection: Boolean!
  stitchingExchange: Boolean!
  stitchingGravity: Boolean!
  stitchingKaws: Boolean!
}

type Money {
  # The ISO-4217 alphabetic currency code, as per https://en.wikipedia.org/wiki/ISO_4217
  currencyCode: String!

  # A pre-formatted price.
  display: String

  # An amount of money expressed in major units (like dollars).
  major(
    # ISO-4217 code of a destination currency for conversion
    convertTo: String
  ): Float!

  # An amount of money expressed in minor units (like cents).
  minor: Int!
}

type Mutation {
  # Create an account request
  createAccountRequest(
    input: CreateAccountRequestMutationInput!
  ): CreateAccountRequestMutationPayload

  # Create a bidder
  createBidder(input: CreateBidderInput!): CreateBidderPayload

  # Creates a bidder position
  createBidderPosition(input: BidderPositionInput!): BidderPositionPayload

  # Create a credit card
  createCreditCard(input: CreditCardInput!): CreditCardPayload

  # Attach an gemini asset to a consignment submission
  createGeminiEntryForAsset(
    input: CreateGeminiEntryForAssetInput!
  ): CreateGeminiEntryForAssetPayload

  # Deletes an image from an artwork in my collection
  deleteArtworkImage(input: DeleteArtworkImageInput!): DeleteArtworkImagePayload

  # Remove a credit card
  deleteCreditCard(input: DeleteCreditCardInput!): DeleteCreditCardPayload

  # Mark sale as ended.
  endSale(input: EndSaleInput!): EndSalePayload

  # Follow (or unfollow) an artist
  followArtist(input: FollowArtistInput!): FollowArtistPayload

  # Follow (or unfollow) an gene
  followGene(input: FollowGeneInput!): FollowGenePayload

  # Follow (or unfollow) a profile
  followProfile(input: FollowProfileInput!): FollowProfilePayload

  # Follow (or unfollow) a show
  followShow(input: FollowShowInput!): FollowShowPayload

  # Create an artwork in my collection
  myCollectionCreateArtwork(
    input: MyCollectionCreateArtworkInput!
  ): MyCollectionCreateArtworkPayload

  # Deletes an artwork from my collection
  myCollectionDeleteArtwork(
    input: MyCollectionDeleteArtworkInput!
  ): MyCollectionDeleteArtworkPayload

  # Update an artwork in my collection
  myCollectionUpdateArtwork(
    input: MyCollectionUpdateArtworkInput!
  ): MyCollectionUpdateArtworkPayload

  # Attach an gemini asset to a consignment submission
  requestCredentialsForAssetUpload(
    input: RequestCredentialsForAssetUploadInput!
  ): RequestCredentialsForAssetUploadPayload

  # Save (or remove) an artwork to (from) a users default collection.
  saveArtwork(input: SaveArtworkInput!): SaveArtworkPayload

  # Send a confirmation email
  sendConfirmationEmail(
    input: SendConfirmationEmailMutationInput!
  ): SendConfirmationEmailMutationPayload

  # Appending a message to a conversation thread
  sendConversationMessage(
    input: SendConversationMessageMutationInput!
  ): SendConversationMessageMutationPayload

  # Send a feedback message
  sendFeedback(input: SendFeedbackMutationInput!): SendFeedbackMutationPayload

  # Start an identity verification flow for a pending identity verification
  startIdentityVerification(
    input: startIdentityVerificationMutationInput!
  ): startIdentityVerificationMutationPayload

  # Create an artwork inquiry request
  submitInquiryRequestMutation(
    input: SubmitInquiryRequestMutationInput!
  ): SubmitInquiryRequestMutationPayload

  # Updating a collector profile (loyalty applicant status).
  updateCollectorProfile(
    input: UpdateCollectorProfileInput!
  ): UpdateCollectorProfilePayload

  # Update a conversation.
  updateConversation(
    input: UpdateConversationMutationInput!
  ): UpdateConversationMutationPayload

  # Update the current logged in user.
  updateMyUserProfile(input: UpdateMyProfileInput!): UpdateMyProfilePayload
}

type MyCollectionArtworkMutationDeleteSuccess {
  success: Boolean
}

type MyCollectionArtworkMutationFailure {
  mutationError: GravityMutationError
}

type MyCollectionArtworkMutationSuccess {
  artwork: Artwork
  artworkEdge: MyCollectionEdge
}

union MyCollectionArtworkMutationType =
    MyCollectionArtworkMutationDeleteSuccess
  | MyCollectionArtworkMutationFailure
  | MyCollectionArtworkMutationSuccess

enum MyCollectionArtworkSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  POSITION_ASC
  POSITION_DESC
}

# A connection to a list of items.
type MyCollectionConnection {
  default: Boolean!
  description: String!

  # A list of edges.
  edges: [MyCollectionEdge]
  name: String!
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  private: Boolean!
  totalCount: Int
}

input MyCollectionCreateArtworkInput {
  artistIds: [String]!
  category: String
  clientMutationId: String
  costCurrencyCode: String
  costMinor: Int
  date: String
  depth: String
  editionNumber: String
  editionSize: String
  externalImageUrls: [String]
  height: String
  isEdition: Boolean
  medium: String!
  metric: String
  provenance: String
  title: String
  width: String
}

type MyCollectionCreateArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

input MyCollectionDeleteArtworkInput {
  artworkId: String!
  clientMutationId: String
}

type MyCollectionDeleteArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

# An edge in a connection.
type MyCollectionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

input MyCollectionUpdateArtworkInput {
  artistIds: [String]
  artworkId: String!
  category: String
  clientMutationId: String
  costCurrencyCode: String
  costMinor: Int
  date: String
  depth: String
  editionNumber: String
  editionSize: String
  externalImageUrls: [String]
  height: String
  isEdition: Boolean
  medium: String
  metric: String
  provenance: String
  title: String
  width: String
}

type MyCollectionUpdateArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

input Near {
  lat: Float!
  lng: Float!
  maxDistance: Float
}

# An object with a Globally Unique ID
interface Node {
  # A globally unique ID.
  id: ID!
}

type OpeningHoursArray {
  schedules: [FormattedDaySchedules]
}

type OpeningHoursText {
  text: String
}

union OpeningHoursUnion = OpeningHoursArray | OpeningHoursText

type OrderedSet {
  cached: Int
  description(format: Format): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  items: [OrderedSetItem]

  # Returns a connection of the items. Only Artwork supported right now.
  itemsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
    @deprecated(reason: "Utilize `orderedItemsConnection` for union type")
  itemType: String
  key: String
  layout: OrderedSetLayouts!
  name: String
  orderedItemsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): OrderedSetItemConnection!
}

# A connection to a list of items.
type OrderedSetConnection {
  # A list of edges.
  edges: [OrderedSetEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type OrderedSetEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: OrderedSet
}

union OrderedSetItem = Artist | Artwork | FeaturedLink | Gene | Sale | Show

# A connection to a list of items.
type OrderedSetItemConnection {
  # A list of edges.
  edges: [OrderedSetItemEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type OrderedSetItemEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: OrderedSetItem
}

enum OrderedSetLayouts {
  DEFAULT
  FULL
}

enum OrderedSetSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  INTERNAL_NAME_ASC
  INTERNAL_NAME_DESC
  ITEM_TYPE_ASC
  ITEM_TYPE_DESC
  KEY_ASC
  KEY_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_TYPE_ASC
  OWNER_TYPE_DESC
}

union OrderParty = Partner | User

type organizer {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  profile: Profile
  profileID: ID

  # A slug ID.
  slug: ID!
  website: String
}

type PageCursor {
  cursor: String!
  isCurrent: Boolean!
  page: Int!
}

type PageCursors {
  # Always includes current page
  around: [PageCursor!]!

  # Optional, may be included in `around` (if current page is near the beginning).
  first: PageCursor

  # Optional, may be included in `around` (if current page is near the end).
  last: PageCursor
  previous: PageCursor
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

type Partner implements Node {
  # A connection of artists at a partner.
  artistsConnection(
    after: String
    before: String
    first: Int
    last: Int
    representedBy: Boolean
    sort: ArtistSorts
  ): ArtistPartnerConnection

  # A connection of artworks from a Partner.
  artworksConnection(
    after: String
    before: String
    exclude: [String]
    first: Int
    forSale: Boolean
    last: Int
    sort: ArtworkSorts
  ): ArtworkConnection
  cached: Int
  categories: [PartnerCategory]

  # A list of the partners unique city locations
  cities(size: Int = 25): [String]
  collectingInstitution: String
  counts: PartnerCounts
  defaultProfileID: String
  hasFairPartnership: Boolean
  href: String

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isDefaultProfilePublic: Boolean
  isLinkable: Boolean
  isPreQualify: Boolean

  # Indicates the partner is a trusted seller on Artsy
  isVerifiedSeller: Boolean

  # This field is deprecated and is being used in Eigen release predating the 6.0 release
  locations(size: Int = 25): [Location]
    @deprecated(
      reason: "Prefer to use `locationsConnection`. [Will be removed in v2]"
    )

  # A connection of locations from a Partner.
  locationsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): LocationConnection
  name: String
  profile: Profile

  # A connection of shows from a Partner.
  showsConnection(
    after: String
    before: String

    # Only used when status is CLOSING_SOON or UPCOMING. Number of days used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int
    last: Int
    sort: ShowSorts

    # Filter shows by chronological event status
    status: EventStatus = CURRENT
  ): ShowConnection

  # A slug ID.
  slug: ID!
  type: String

  # The gallery partner's web address
  website: String
}

type PartnerArtist {
  artist: Artist
  biography: String
  counts: PartnerArtistCounts

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isUseDefaultBiography: Boolean
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

# A connection to a list of items.
type PartnerArtistConnection {
  # A list of edges.
  edges: [PartnerArtistEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type PartnerArtistCounts {
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  forSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type PartnerArtistEdge {
  artist: Artist
  biography: String
  counts: PartnerArtistCounts

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isUseDefaultBiography: Boolean

  # The item at the end of the edge
  node: Partner
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

type PartnerArtworkGrid implements ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

type PartnerCategory {
  cached: Int
  categoryType: PartnerCategoryType

  # A globally unique ID.
  id: ID!
  internal: Boolean

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String
  partners(
    defaultProfilePublic: Boolean
    eligibleForCarousel: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Indicates tier 1/2 for gallery, 1 for institution
    eligibleForPrimaryBucket: Boolean

    # Indicates tier 3/4 for gallery, 2 for institution
    eligibleForSecondaryBucket: Boolean
    hasFullProfile: Boolean
    ids: [String]

    # Coordinates to find partners closest to
    near: String
    page: Int

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    size: Int
    sort: PartnersSortType

    # term used for searching Partners
    term: String
    type: [PartnerClassification]
  ): [Partner]

  # A slug ID.
  slug: ID!
}

enum PartnerCategoryType {
  GALLERY
  INSTITUTION
}

enum PartnerClassification {
  AUCTION
  BRAND
  DEMO
  GALLERY
  INSTITUTION
  INSTITUTIONAL_SELLER
  PRIVATE_COLLECTOR
  PRIVATE_DEALER
}

# A connection to a list of items.
type PartnerConnection {
  # A list of edges.
  edges: [PartnerEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type PartnerCounts {
  artistDocuments(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  currentDisplayableShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  displayableShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  eligibleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerShowDocuments(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  publishedForSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  publishedNotForSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  shows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type PartnerEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Partner
}

enum PartnerShowPartnerType {
  GALLERY
  MUSEUM
}

enum PartnersSortType {
  CREATED_AT_ASC
  CREATED_AT_DESC
  PUBLISHED_AT_DESC
  RANDOM_SCORE_DESC
  RELATIVE_SIZE_ASC
  RELATIVE_SIZE_DESC
  SORTABLE_ID_ASC
  SORTABLE_ID_DESC
}

union PartnerTypes = ExternalPartner | Partner

type PriceRange {
  display: String
  maxPrice: Money
  minPrice: Money
}

type Profile {
  bio: String
  cached: Int
  counts: ProfileCounts
  href: String
  icon: Image

  # A globally unique ID.
  id: ID!
  image: Image
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isFollowed: Boolean
  isPubliclyVisible: Boolean
  isPublished: Boolean
  name: String

  # A slug ID.
  slug: ID!
}

type ProfileCounts {
  follows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type Query {
  # Do not use (only used internally for stitching)
  _do_not_use_image: Image

  # An Article
  article(
    # The ID of the Article
    id: String!
  ): Article

  # A list of Articles
  articles(
    auctionID: String

    #
    #         Only return articles matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    published: Boolean = true
    showID: String
    sort: ArticleSorts
  ): [Article]

  # An Artist
  artist(
    # The slug or ID of the Artist
    id: String!
  ): Artist

  # A list of Artists
  artists(
    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    page: Int = 1
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): [Artist]

  # A list of artists
  artistsConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    last: Int
    letter: String
    page: Int
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): ArtistConnection

  # An Artwork
  artwork(
    # The slug or ID of the Artwork
    id: String!

    # Include unlisted artwork or not
    includeUnlisted: Boolean
  ): Artwork

  # List of all artwork attribution classes
  artworkAttributionClasses: [AttributionClass]

  # List of all artwork mediums
  artworkMediums: [ArtworkMedium]

  # A list of Artworks
  artworks(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
    respectParamsOrder: Boolean = false
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # Artworks Elastic Search results
  artworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # An auction result
  auctionResult(
    # The ID of the auction result
    id: String!
  ): AuctionResult

  # A city-based entry point for local discovery
  city(
    # A point which will be used to locate the nearest local discovery city within a threshold
    near: Near

    # A slug for the city, conforming to Gravity's city slug naming conventions
    slug: String
  ): City

  # A user's credit card
  creditCard(
    # The ID of the Credit Card
    id: String!
  ): CreditCard

  # A Fair
  fair(
    # The slug or ID of the Fair
    id: String!
  ): Fair

  # A list of Fairs
  fairs(
    fairOrganizerID: String
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    #
    #         Only return fairs matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    near: Near
    page: Int
    size: Int
    sort: FairSorts
    status: EventStatus
  ): [Fair]

  # A Feature
  feature(
    # The slug or ID of the Feature
    id: ID
  ): Feature
  gene(
    # The slug or ID of the Gene
    id: String!
  ): Gene

  # A list of Gene Families
  geneFamiliesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): GeneFamilyConnection

  # A list of Genes
  genes(
    size: Int

    #
    #         Only return genes matching specified slugs.
    #         Accepts list of slugs.
    #
    slugs: [String]
  ): [Gene]
  highlights: Highlights

  # Home screen content
  homePage: HomePage
  me: Me

  # Fetches an object given its globally unique ID.
  node(
    # The globally unique ID of the node.
    id: ID!
  ): Node

  # An OrderedSet
  orderedSet(
    # The ID of the OrderedSet
    id: String!
  ): OrderedSet

  # A collection of OrderedSets
  orderedSets(
    # Key to the OrderedSet or group of OrderedSets
    key: String!
    public: Boolean = true
  ): [OrderedSet]

  # A Partner
  partner(
    # The slug or ID of the Partner
    id: String!
  ): Partner

  # A list of Artworks for a partner
  partnerArtworks(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: String!
    private: Boolean
    viewingRoomID: String
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # A list of Partners
  partnersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): PartnerConnection

  # A Sale
  sale(
    # The slug or ID of the Sale
    id: String!
  ): Sale

  # A Sale Artwork
  saleArtwork(
    # The slug or ID of the SaleArtwork
    id: String!
  ): SaleArtwork

  # Sale Artworks search results
  saleArtworksConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    estimateRange: String
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    page: Int
    saleID: ID
    size: Int
    sort: String
  ): SaleArtworksConnection

  # A list of Sales
  salesConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts
  ): SaleConnection

  # Global search
  searchConnection(
    after: String
    aggregations: [SearchAggregation]
    before: String

    # Entities to include in search. Default: [ARTIST, ARTWORK].
    entities: [SearchEntity]
    first: Int
    last: Int

    # Mode of search to execute. Default: SITE.
    mode: SearchMode

    # If present, will be used for pagination instead of cursors.
    page: Int

    # Search query to perform. Required.
    query: String!
  ): SearchableConnection

  # A Show
  show(
    # The slug or ID of the Show
    id: String!
  ): Show

  # A list of Shows
  showsConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): ShowConnection

  # Content for a specific page or view
  staticContent(
    # The slug or id for the view
    id: String!
  ): StaticContent

  # Fields related to internal systems.
  system: System
  tag(
    # The slug or ID of the Tag
    id: String!
  ): Tag
  targetSupply: TargetSupply
  user(
    # Email to search for user by
    email: String

    # ID of the user
    id: String
  ): User

  # A list of Users
  usersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): UserConnection

  # A Partner or Fair
  vanityURLEntity(
    # The slug or ID of the Profile to get a partner or fair for
    id: String!
  ): VanityURLEntityType

  # A wildcard used to support complex root queries in Relay
  viewer: Viewer
}

enum RelatedArtistsKind {
  CONTEMPORARY
  MAIN
}

type RelatedArtworkGrid implements ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

input RequestCredentialsForAssetUploadInput {
  # The desired access control
  acl: String!
  clientMutationId: String

  # The gemini template you want to request
  name: String!
}

type RequestCredentialsForAssetUploadPayload {
  asset: Credentials
  clientMutationId: String
}

type ResizedImageUrl {
  factor: Float!
  height: Int
  src: String!
  srcSet: String!
  url: String!
  width: Int
}

enum Role {
  OPERATOR
  PARTICIPANT
}

# The conditions for uploading assets to media.artsy.net
type S3PolicyConditionsType {
  # The assigned access control
  acl: String!

  # The bucket to upload to.
  bucket: String!

  # A key which is prefixed on your file
  geminiKey: String!

  # The returned status code, currently always 201
  successActionStatus: String!
}

# An policy for uploading assets to media.artsy.net
type S3PolicyDocumentType {
  # The details for the upload
  conditions: S3PolicyConditionsType!

  # An expiration date string.
  expiration: String!
}

type Sale implements Node {
  # Returns a connection of artworks for a sale.
  artworksConnection(
    after: String
    before: String

    # List of artwork IDs to exclude from the response (irrespective of size)
    exclude: [String]
    first: Int
    last: Int
  ): ArtworkConnection
  associatedSale: Sale

  # A bid increment policy that explains minimum bids in ranges.
  bidIncrements: [BidIncrement]

  # Auction's buyer's premium policy.
  buyersPremium: [BuyersPremium]
  cached: Int
  collectPayments: Boolean!
  coverImage: Image
  currency: String
  description: String
  displayTimelyAt: String
  eligibleSaleArtworksCount: Int
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  eventEndAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  eventStartAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A formatted description of when the auction starts or ends or if it has ended
  formattedStartDateTime: String
  href: String

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isArtsyLicensed: Boolean!
  isAuction: Boolean
  isAuctionPromo: Boolean
  isBenefit: Boolean
  isClosed: Boolean
  isGalleryAuction: Boolean
  isLiveOpen: Boolean
  isLotConditionsReportEnabled: Boolean
  isOpen: Boolean
  isPreliminary: Boolean
  isPreview: Boolean
  isRegistrationClosed: Boolean
  isWithBuyersPremium: Boolean
  liveStartAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Returns a live auctions url if the sale is open and start time is after now
  liveURLIfOpen: String
  name: String
  partner: Partner
  profile: Profile
  promotedSale: Sale
  registrationEndsAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A registration for this sale or null
  registrationStatus: Bidder
  requireBidderApproval: Boolean
  requireIdentityVerification: Boolean
  saleArtwork(id: String!): SaleArtwork
  saleArtworksConnection(
    after: String
    all: Boolean = false
    before: String
    first: Int

    # List of sale artwork internal IDs to fetch
    internalIDs: [ID]
    last: Int
  ): SaleArtworkConnection
  saleType: String

  # A slug ID.
  slug: ID!
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  status: String
  symbol: String
  timeZone: String

  # True if the current user needs to undergo identity verification for this sale, false otherwise
  userNeedsIdentityVerification: Boolean
}

type SaleArtwork implements ArtworkEdgeInterface & Node {
  artwork: Artwork
  cached: Int
  calculatedCost(
    # Max bid price for the sale artwork
    bidAmountMinor: Int!
  ): CalculatedCost
  counts: SaleArtworkCounts

  # Currency abbreviation (e.g. "USD")
  currency: String
  currentBid: SaleArtworkCurrentBid
  cursor: String
  estimate: String

  # Singular estimate field, if specified
  estimateCents: Int
  highestBid: SaleArtworkHighestBid
  highEstimate: SaleArtworkHighEstimate

  # A globally unique ID.
  id: ID!
  increments(
    # Whether or not to start the increments at the user's latest bid
    useMyMaxBid: Boolean
  ): [BidIncrementsFormatted]

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Can bids be placed on the artwork?
  isBiddable: Boolean
  isBidOn: Boolean
  isWithReserve: Boolean
  lotLabel: String
  lowEstimate: SaleArtworkLowEstimate
  minimumNextBid: SaleArtworkMinimumNextBid
  node: Artwork
  openingBid: SaleArtworkOpeningBid
  position: Float
  reserve: SaleArtworkReserve
  reserveMessage: String
  reserveStatus: String
  sale: Sale
  saleID: String

  # A slug ID.
  slug: ID!

  # Currency symbol (e.g. "$")
  symbol: String
}

enum SaleArtworkAggregation {
  ARTIST
  FOLLOWED_ARTISTS
  MEDIUM
  TOTAL
}

# A connection to a list of items.
type SaleArtworkConnection {
  # A list of edges.
  edges: [SaleArtworkEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type SaleArtworkCounts {
  bidderPositions(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type SaleArtworkCurrentBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

# An edge in a connection.
type SaleArtworkEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: SaleArtwork
}

type SaleArtworkHighestBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  display: String
  isCancelled: Boolean
}

type SaleArtworkHighEstimate {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkLowEstimate {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkMinimumNextBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkOpeningBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkReserve {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

# The results for one of the requested aggregations
type SaleArtworksAggregationResults {
  counts: [AggregationCount]
  slice: SaleArtworkAggregation
}

# A connection to a list of items.
type SaleArtworksConnection implements ArtworkConnectionInterface {
  # Returns aggregation counts for the given filter query.
  aggregations: [SaleArtworksAggregationResults]
  counts: FilterSaleArtworksCounts

  # A list of edges.
  edges: [SaleArtwork]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# A connection to a list of items.
type SaleConnection {
  # A list of edges.
  edges: [SaleEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type SaleEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Sale
}

type SaleRegistration {
  bidder: Bidder

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isRegistered: Boolean
  sale: Sale
}

# A connection to a list of items.
type SaleRegistrationConnection {
  # A list of edges.
  edges: [SaleRegistrationEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type SaleRegistrationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: SaleRegistration
}

enum SaleSorts {
  _ID_ASC
  _ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ELIGIBLE_SALE_ARTWORKS_COUNT_ASC
  ELIGIBLE_SALE_ARTWORKS_COUNT_DESC
  END_AT_ASC
  END_AT_DESC
  NAME_ASC
  NAME_DESC
  START_AT_ASC
  START_AT_DESC
  TIMELY_AT_NAME_ASC
  TIMELY_AT_NAME_DESC
}

input SaveArtworkInput {
  artworkID: String
  clientMutationId: String
  remove: Boolean
}

type SaveArtworkPayload {
  artwork: Artwork
  clientMutationId: String
}

# A connection to a list of items.
type SavedArtworksConnection {
  default: Boolean!
  description: String!

  # A list of edges.
  edges: [SavedArtworksEdge]
  name: String!
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  private: Boolean!
  totalCount: Int
}

# An edge in a connection.
type SavedArtworksEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

# An object that may be searched for
interface Searchable {
  displayLabel: String
  href: String
  imageUrl: String
}

# A connection to a list of items.
type SearchableConnection {
  # Returns aggregation counts for the given filter query.
  aggregations: [SearchAggregationResults]

  # A list of edges.
  edges: [SearchableEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type SearchableEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Searchable
}

type SearchableItem implements Node & Searchable {
  description: String
  displayLabel: String
  displayType: String
  href: String

  # A globally unique ID.
  id: ID!
  imageUrl: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # A slug ID.
  slug: ID!
}

enum SearchAggregation {
  TYPE
}

# The results for a requested aggregations
type SearchAggregationResults {
  counts: [AggregationCount]
  slice: SearchAggregation
}

enum SearchEntity {
  ARTICLE
  ARTIST
  ARTIST_SERIES
  ARTWORK
  CITY
  COLLECTION
  FAIR
  FEATURE
  GALLERY
  GENE
  INSTITUTION
  PAGE
  PROFILE
  SALE
  SHOW
  TAG
  VIEWING_ROOM
}

enum SearchMode {
  AUTOSUGGEST
  SITE
}

# A piece that can be sold
interface Sellable {
  dimensions: dimensions
  editionOf: String

  # Whether a piece can be purchased through e-commerce
  isAcquireable: Boolean
  isForSale: Boolean

  # Whether a user can make an offer on the work
  isOfferable: Boolean
  isSold: Boolean
  saleMessage: String
}

type SendConfirmationEmailMutationFailure {
  mutationError: GravityMutationError
}

input SendConfirmationEmailMutationInput {
  clientMutationId: String
}

type SendConfirmationEmailMutationPayload {
  clientMutationId: String
  confirmationOrError: SendConfirmationEmailMutationType
}

type SendConfirmationEmailMutationSuccess {
  confirmationSentAt: String
  unconfirmedEmail: String
}

union SendConfirmationEmailMutationType =
    SendConfirmationEmailMutationFailure
  | SendConfirmationEmailMutationSuccess

input SendConversationMessageMutationInput {
  bodyText: String!
  clientMutationId: String

  # The email address of the message sender
  from: String!

  # The id of the conversation to be updated
  id: String!

  # The message being replied to
  replyToMessageID: String!
}

type SendConversationMessageMutationPayload {
  clientMutationId: String
  conversation: Conversation
  messageEdge: MessageEdge
}

type SendFeedbackMutationFailure {
  mutationError: GravityMutationError
}

input SendFeedbackMutationInput {
  clientMutationId: String

  # Email to associate with message (only used if logged out).
  email: String

  # Message to be sent.
  message: String!

  # Name to associate with message (only used if logged out).
  name: String

  # URL of page where feedback originated.
  url: String
}

type SendFeedbackMutationPayload {
  clientMutationId: String
  feedbackOrError: SendFeedbackMutationType
}

type SendFeedbackMutationSuccess {
  feedback: Feedback
}

union SendFeedbackMutationType =
    SendFeedbackMutationFailure
  | SendFeedbackMutationSuccess

type Services {
  convection: ConvectionService!
  metaphysics: MetaphysicsService!
}

type Show implements EntityWithFilterArtworksConnectionInterface & Node {
  # The Artists presenting in this show
  artists: [Artist]

  # Artists in the show grouped by last name
  artistsGroupedByName: [ArtistGroup]

  # Artists inside the show who do not have artworks present
  artistsWithoutArtworks: [Artist]

  # The artworks featured in the show
  artworksConnection(
    after: String
    before: String

    # List of artwork IDs to exclude from the response (irrespective of size)
    exclude: [String]
    first: Int
    forSale: Boolean = false
    last: Int
    published: Boolean = true
  ): ArtworkConnection
  cached: Int

  # The general city, derived from a fair location, a show location or a potential city
  city: String

  # An object that represents some of the numbers you might want to highlight
  counts: ShowCounts

  # The image you should use to represent this show
  coverImage: Image
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # A description of the show
  description: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Events from the partner that runs this show
  events: [ShowEventType]

  # A formatted description of the start to end dates
  exhibitionPeriod: String

  # If the show is in a Fair, then that fair
  fair: Fair

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A Connection of followed artists by current user for this show
  followedArtistsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ShowFollowArtistConnection

  # Flag showing if show has any location.
  hasLocation: Boolean

  # A path to the show on Artsy
  href: String

  # A globally unique ID.
  id: ID!

  # Images that represent the show, you may be interested in meta_image or cover_image for a definitive thumbnail
  images(
    # Pass true/false to include cover or not
    default: Boolean
    page: Int

    # Number of images to return
    size: Int
  ): [Image]

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Gravity doesn’t expose the `active` flag. Temporarily re-state its logic.
  isActive: Boolean

  # Is this something we can display to the front-end?
  isDisplayable: Boolean

  # Does the show exist as a fair booth?
  isFairBooth: Boolean

  # Is the user following this show
  isFollowed: Boolean

  # Is it a show provided for historical reference?
  isReference: Boolean

  # Is it an outsourced local discovery stub show?
  isStubShow: Boolean

  # Whether the show is in a fair, group or solo
  kind: String

  # Where the show is located (Could also be a fair location)
  location: Location

  # An image representing the show, or a sharable image from an artwork in the show
  metaImage: Image

  # The exhibition title
  name: String

  # Shows that are near (~75km) from this show
  nearbyShowsConnection(
    after: String
    before: String

    # Whether to include local discovery stubs as well as displayable shows
    discoverable: Boolean
    first: Int
    last: Int
    sort: ShowSorts

    # By default show only current shows
    status: EventStatus
  ): ShowConnection

  # Alternate Markdown-supporting free text representation of the opening reception event’s date/time
  openingReceptionText: String

  # The partner that represents this show, could be a non-Artsy partner
  partner: PartnerTypes

  # The press release for this show
  pressRelease(format: Format): String

  # Link to the press release for this show
  pressReleaseUrl: String

  # A slug ID.
  slug: ID!

  # When this show starts
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String

  # Is this show running, upcoming or closed?
  status: String

  # A formatted update on upcoming status changes
  statusUpdate(
    # Before this many days no update will be generated
    maxDays: Int
  ): String

  # Is it a fair booth or a show?
  type: String
  viewingRoomIDs: [String!]!
}

type ShowArtworkGrid implements ArtworkContextGrid {
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# A connection to a list of items.
type ShowConnection {
  # A list of edges.
  edges: [ShowEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type ShowCounts {
  artists: Int
  artworks(
    # The slug or ID of an artist in the show.
    artistID: String
  ): Int
  eligibleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type ShowEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Show
}

type ShowEventType {
  # A formatted description of the dates with hours
  dateTimeRange: String
  description: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  eventType: String

  # A formatted description of the start to end dates
  exhibitionPeriod: String
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  title: String
}

type ShowFollowArtist {
  artist: Artist
}

# A connection to a list of items.
type ShowFollowArtistConnection {
  # A list of edges.
  edges: [ShowFollowArtistEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ShowFollowArtistEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ShowFollowArtist
}

enum ShowSorts {
  END_AT_ASC
  END_AT_DESC
  FEATURED_ASC
  FEATURED_DESC
  NAME_ASC
  NAME_DESC
  PARTNER_ASC
  SORTABLE_NAME_ASC
  SORTABLE_NAME_DESC
  START_AT_ASC
  START_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

enum sort {
  ASC
  DESC
}

type StartIdentityVerificationFailure {
  mutationError: GravityMutationError
}

input startIdentityVerificationMutationInput {
  clientMutationId: String

  # Primary ID of the identity verification to be started
  identityVerificationId: String!
}

type startIdentityVerificationMutationPayload {
  clientMutationId: String
  startIdentityVerificationResponseOrError: StartIdentityVerificationResponseOrError
}

union StartIdentityVerificationResponseOrError =
    StartIdentityVerificationFailure
  | StartIdentityVerificationSuccess

type StartIdentityVerificationSuccess {
  # URL that hosts the user-facing identity verification flow (Jumio)
  identityVerificationFlowUrl: String

  # Primary ID of the started identity verification
  identityVerificationId: String
}

type StaticContent {
  content: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String

  # A slug ID.
  slug: ID!
}

input SubmitInquiryRequestMutationInput {
  clientMutationId: String

  # The inquireable object id (Artwork ID or Show ID)
  inquireableID: String!

  # The type of inquireable object (Artwork or Show)
  inquireableType: String!

  # Optional inquiry message
  message: String

  # List of structured inquiry questions
  questions: [InquiryQuestionInput]
}

type SubmitInquiryRequestMutationPayload {
  clientMutationId: String

  # Artwork Inquiry request
  inquiryRequest: InquiryRequest
}

type System {
  # Creates, and authorizes, a JWT custom for Causality
  causalityJWT(
    role: Role

    # The id of the auction to participate in
    saleID: String!
  ): String

  # The schema for difference micro-service settings
  services: Services

  # Gravity system time, necessary for synchronizing device clocks.
  time: SystemTime
}

type SystemTime {
  day: Int
  dst: Boolean
  hour: Int
  iso8601: String
  min: Int
  month: Int
  sec: Int
  unix: Int
  utcOffset: Int
  wday: Int
  year: Int
  zone: String
}

type Tag implements Node {
  cached: Int
  count: Int
  description: String

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String

  # A slug ID.
  slug: ID!
}

type TargetSupply {
  microfunnel: [TargetSupplyMicrofunnelItem]
}

type TargetSupplyMicrofunnelItem {
  artist: Artist

  # A list of recently sold artworks.
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Randomize the order of artworks for display purposes.
    randomize: Boolean
  ): ArtworkConnection
  metadata: TargetSupplyMicrofunnelMetadata
}

type TargetSupplyMicrofunnelMetadata {
  highestRealized: String
  realized: String
  recentlySoldArtworkIDs: [String]
  roundedUniqueVisitors: String
  roundedViews: String
  str: String
  uniqueVisitors: String
  views: String
}

type TrendingArtists {
  artists: [Artist]
}

union UnderlyingCurrentEvent = Sale | Show

input UpdateCollectorProfileInput {
  clientMutationId: String
  intents: [Intents]
  loyaltyApplicant: Boolean
  professionalBuyer: Boolean
  selfReportedPurchases: String
}

type UpdateCollectorProfilePayload {
  clientMutationId: String
  collectorLevel: Int
  confirmedBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  email: String

  # A globally unique ID.
  id: ID!
  intents: [String]

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  loyaltyApplicantAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  name: String
  professionalBuyerAppliedAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  professionalBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to `X-TIMEZONE` header
    timezone: String
  ): String
  selfReportedPurchases: String
}

input UpdateConversationMutationInput {
  clientMutationId: String

  # The id of the conversation to be updated.
  conversationId: String!

  # The message id to mark as read.
  fromLastViewedMessageId: String!
}

type UpdateConversationMutationPayload {
  clientMutationId: String
  conversation: Conversation
}

input UpdateMyProfileInput {
  clientMutationId: String

  # The collector level for the user
  collectorLevel: Int

  # The given email of the user.
  email: String

  # Frequency of marketing emails.
  emailFrequency: String

  # The given location of the user as structured data
  location: EditableLocation

  # The given name of the user.
  name: String

  # The user's password, required to change email address.
  password: String

  # The given phone number of the user.
  phone: String

  # The maximum price collector has selected
  priceRangeMax: Float

  # The minimum price collector has selected
  priceRangeMin: Int

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean
}

union UpdateMyProfileMutation =
    UpdateMyProfileMutationFailure
  | UpdateMyProfileMutationSuccess

type UpdateMyProfileMutationFailure {
  mutationError: GravityMutationError
}

type UpdateMyProfileMutationSuccess {
  user: User
}

type UpdateMyProfilePayload {
  clientMutationId: String
  me: Me
  user: User
  userOrError: UpdateMyProfileMutation
}

type User {
  cached: Int

  # The given email of the user.
  email: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # The given location of the user as structured data
  location: Location

  # The given name of the user.
  name: String!

  # The paddle number of the user
  paddleNumber: String

  # The given phone number of the user.
  phone: String

  # Pin for bidding at an auction
  pin: String

  # The price range the collector has selected
  priceRange: String

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean

  # Check whether a user exists by email address before creating an account.
  userAlreadyExists: Boolean
}

# A connection to a list of items.
type UserConnection {
  # A list of edges.
  edges: [UserEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: User
}

union VanityURLEntityType = Fair | Partner

# A wildcard used to support complex root queries in Relay
type Viewer {
  # Do not use (only used internally for stitching)
  _do_not_use_image: Image

  # An Article
  article(
    # The ID of the Article
    id: String!
  ): Article

  # A list of Articles
  articles(
    auctionID: String

    #
    #         Only return articles matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    published: Boolean = true
    showID: String
    sort: ArticleSorts
  ): [Article]

  # An Artist
  artist(
    # The slug or ID of the Artist
    id: String!
  ): Artist

  # A list of Artists
  artists(
    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    page: Int = 1
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): [Artist]

  # A list of artists
  artistsConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    last: Int
    letter: String
    page: Int
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): ArtistConnection

  # An Artwork
  artwork(
    # The slug or ID of the Artwork
    id: String!

    # Include unlisted artwork or not
    includeUnlisted: Boolean
  ): Artwork

  # List of all artwork attribution classes
  artworkAttributionClasses: [AttributionClass]

  # List of all artwork mediums
  artworkMediums: [ArtworkMedium]

  # A list of Artworks
  artworks(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
    respectParamsOrder: Boolean = false
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # Artworks Elastic Search results
  artworksConnection(
    acquireable: Boolean
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistSeriesID: String
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # An auction result
  auctionResult(
    # The ID of the auction result
    id: String!
  ): AuctionResult

  # A city-based entry point for local discovery
  city(
    # A point which will be used to locate the nearest local discovery city within a threshold
    near: Near

    # A slug for the city, conforming to Gravity's city slug naming conventions
    slug: String
  ): City

  # A user's credit card
  creditCard(
    # The ID of the Credit Card
    id: String!
  ): CreditCard

  # A Fair
  fair(
    # The slug or ID of the Fair
    id: String!
  ): Fair

  # A list of Fairs
  fairs(
    fairOrganizerID: String
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    #
    #         Only return fairs matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    near: Near
    page: Int
    size: Int
    sort: FairSorts
    status: EventStatus
  ): [Fair]

  # A Feature
  feature(
    # The slug or ID of the Feature
    id: ID
  ): Feature
  gene(
    # The slug or ID of the Gene
    id: String!
  ): Gene

  # A list of Gene Families
  geneFamiliesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): GeneFamilyConnection

  # A list of Genes
  genes(
    size: Int

    #
    #         Only return genes matching specified slugs.
    #         Accepts list of slugs.
    #
    slugs: [String]
  ): [Gene]
  highlights: Highlights

  # Home screen content
  homePage: HomePage
  me: Me

  # Fetches an object given its globally unique ID.
  node(
    # The globally unique ID of the node.
    id: ID!
  ): Node

  # An OrderedSet
  orderedSet(
    # The ID of the OrderedSet
    id: String!
  ): OrderedSet

  # A collection of OrderedSets
  orderedSets(
    # Key to the OrderedSet or group of OrderedSets
    key: String!
    public: Boolean = true
  ): [OrderedSet]

  # A Partner
  partner(
    # The slug or ID of the Partner
    id: String!
  ): Partner

  # A list of Artworks for a partner
  partnerArtworks(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: String!
    private: Boolean
    viewingRoomID: String
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # A list of Partners
  partnersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): PartnerConnection

  # A Sale
  sale(
    # The slug or ID of the Sale
    id: String!
  ): Sale

  # A Sale Artwork
  saleArtwork(
    # The slug or ID of the SaleArtwork
    id: String!
  ): SaleArtwork

  # Sale Artworks search results
  saleArtworksConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    estimateRange: String
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    page: Int
    saleID: ID
    size: Int
    sort: String
  ): SaleArtworksConnection

  # A list of Sales
  salesConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts
  ): SaleConnection

  # Global search
  searchConnection(
    after: String
    aggregations: [SearchAggregation]
    before: String

    # Entities to include in search. Default: [ARTIST, ARTWORK].
    entities: [SearchEntity]
    first: Int
    last: Int

    # Mode of search to execute. Default: SITE.
    mode: SearchMode

    # If present, will be used for pagination instead of cursors.
    page: Int

    # Search query to perform. Required.
    query: String!
  ): SearchableConnection

  # A Show
  show(
    # The slug or ID of the Show
    id: String!
  ): Show

  # A list of Shows
  showsConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): ShowConnection

  # Content for a specific page or view
  staticContent(
    # The slug or id for the view
    id: String!
  ): StaticContent

  # Fields related to internal systems.
  system: System
  tag(
    # The slug or ID of the Tag
    id: String!
  ): Tag
  targetSupply: TargetSupply
  user(
    # Email to search for user by
    email: String

    # ID of the user
    id: String
  ): User

  # A list of Users
  usersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
  ): UserConnection

  # A Partner or Fair
  vanityURLEntity(
    # The slug or ID of the Profile to get a partner or fair for
    id: String!
  ): VanityURLEntityType
}

type YearRange {
  # The last year of the year range
  endAt: Int

  # The first year of the year range
  startAt: Int
}
